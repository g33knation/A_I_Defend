import asyncio
import json
import logging
import re
from pathlib import Path
from typing import Dict, Any, List, Optional
from .base_scanner import BaseScanner

logger = logging.getLogger(__name__)

class LynisScanner(BaseScanner):
    """Lynis security auditing tool scanner."""
    
    # Default categories to scan
    DEFAULT_CATEGES = [
        "authentication",
        "banners",
        "boot_services",
        "containers",
        "dns",
        "file_integrity",
        "file_permissions",
        "firewalls",
        "kernel",
        "logging",
        "malware",
        "memory_processes",
        "networking",
        "php",
        "processes",
        "ssh",
        "storage",
        "time",
        "tools",
        "webservers"
    ]
    
    def __init__(self, config: Dict[str, Any] = None):
        """Initialize the Lynis scanner.
        
        Args:
            config: Configuration dictionary with optional keys:
                   - categories: List of categories to scan (default: all)
                   - sudo: Whether to run with sudo (default: True)
                   - quick: Quick scan mode (default: True)
        """
        super().__init__(config)
        self.categories = self.config.get("categories", self.DEFAULT_CATEGES)
        self.use_sudo = self.config.get("sudo", True)
        self.quick = self.config.get("quick", True)
        self.report_file = None
        
    async def scan(self) -> bool:
        """Run the Lynis audit."""
        try:
            # Create a temporary directory for the report
            import tempfile
            import uuid
            
            report_dir = Path(tempfile.gettempdir()) / f"lynis_{uuid.uuid4()}"
            report_dir.mkdir(parents=True, exist_ok=True)
            
            # Build the Lynis command
            cmd = ["lynis"]
            
            if self.use_sudo:
                cmd.insert(0, "sudo")
                
            cmd.extend(["audit", "system"])
            
            # Add categories
            if self.categories:
                cmd.extend(["--tests-from-category", ",".join(self.categories)])
            
            # Add quick mode
            if self.quick:
                cmd.append("--quick")
                
            # Add report options
            cmd.extend([
                "--no-colors",
                "--quiet",
                "--no-log",
                "--report-file", str(report_dir / "lynis-report.txt"),
                "--report-json", str(report_dir / "lynis-report.json")
            ])
            
            # Run the command
            result = await self.run_command(cmd)
            
            if result["returncode"] != 0 and result["returncode"] != 1:  # Lynis returns 1 for warnings
                error_msg = f"Lynis scan failed: {result['stderr']}"
                logger.error(error_msg)
                self.errors.append(error_msg)
                return False
                
            # Parse the JSON report
            json_report = report_dir / "lynis-report.json"
            if json_report.exists():
                with open(json_report, 'r') as f:
                    report_data = json.load(f)
                self.report_file = str(json_report)
                self.results = self._process_results(report_data)
            else:
                # Fallback to parsing text report if JSON is not available
                txt_report = report_dir / "lynis-report.txt"
                if txt_report.exists():
                    with open(txt_report, 'r') as f:
                        report_text = f.read()
                    self.results = self._parse_text_report(report_text)
                else:
                    error_msg = "No report file generated by Lynis"
                    logger.error(error_msg)
                    self.errors.append(error_msg)
                    return False
            
            return True
            
        except Exception as e:
            error_msg = f"Error during Lynis scan: {str(e)}"
            logger.error(error_msg, exc_info=True)
            self.errors.append(error_msg)
            return False
    
    def _process_results(self, report_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Process Lynis JSON report into a standardized format."""
        results = []
        
        # Process tests
        for test_id, test_data in report_data.get("tests", {}).items():
            if not test_data.get("warnings") and not test_data.get("suggestions"):
                continue
                
            result = {
                "type": "security_audit",
                "severity": self._map_severity(test_data.get("score", 0)),
                "test_id": test_id,
                "test_name": test_data.get("test_name", ""),
                "category": test_data.get("category", ""),
                "timestamp": self.scan_id,
                "warnings": test_data.get("warnings", []),
                "suggestions": test_data.get("suggestions", []),
                "details": {
                    "score": test_data.get("score", 0),
                    "hardening_index": report_data.get("report", {}).get("hardening_index", 0)
                }
            }
            
            results.append(result)
        
        # Process vulnerabilities
        for vuln in report_data.get("vulnerabilities", []):
            result = {
                "type": "vulnerability",
                "severity": "high",
                "test_id": f"vuln_{vuln.get('id', '')}",
                "test_name": vuln.get("description", ""),
                "category": "vulnerability",
                "timestamp": self.scan_id,
                "details": {
                    "package": vuln.get("package", ""),
                    "cve": vuln.get("cve", ""),
                    "cvss": vuln.get("cvss", 0)
                }
            }
            
            results.append(result)
        
        return results
    
    def _parse_text_report(self, report_text: str) -> List[Dict[str, Any]]:
        """Parse Lynis text report if JSON is not available."""
        results = []
        
        # Extract warnings
        warnings_section = re.search(r"Warnings \(([0-9]+)\):([\s\S]*?)(?=\n\[\*\]|\Z)", report_text)
        if warnings_section:
            warnings = warnings_section.group(2).strip().split("\n")
            for warning in warnings:
                if not warning.strip():
                    continue
                    
                result = {
                    "type": "security_audit",
                    "severity": "high",
                    "test_id": f"warn_{len(results) + 1}",
                    "test_name": warning.strip(),
                    "category": "warning",
                    "timestamp": self.scan_id,
                    "details": {
                        "source": "text_report",
                        "raw_warning": warning.strip()
                    }
                }
                
                results.append(result)
        
        # Extract suggestions
        suggestions_section = re.search(r"Suggestions \(([0-9]+)\):([\s\S]*?)(?=\n\[\*\]|\Z)", report_text)
        if suggestions_section:
            suggestions = suggestions_section.group(2).strip().split("\n")
            for suggestion in suggestions:
                if not suggestion.strip():
                    continue
                    
                # Try to extract test ID from suggestion
                test_id = f"sugg_{len(results) + 1}"
                match = re.search(r'\[(.*?)\]', suggestion)
                if match:
                    test_id = match.group(1)
                
                result = {
                    "type": "security_audit",
                    "severity": "medium",
                    "test_id": test_id,
                    "test_name": suggestion.strip(),
                    "category": "suggestion",
                    "timestamp": self.scan_id,
                    "details": {
                        "source": "text_report",
                        "raw_suggestion": suggestion.strip()
                    }
                }
                
                results.append(result)
        
        return results
    
    def _map_severity(self, score: int) -> str:
        """Map Lynis score to severity."""
        if score >= 70:
            return "high"
        elif score >= 40:
            return "medium"
        return "low"
